# android-movie-ticket

## 기능 요구 사항

- 사용자는 영화 예매 시스템에서 등급별 좌석을 선택할 수 있다.
- 영화를 선택한 후 날짜와 시간을 정할 수 있다.
- 화면이 회전되어도 입력한 정보는 유지되어야 한다.
- 사용자는 인원/날짜 선택 후에 좌석을 고를 수 있다.
- 좌석을 선택하면 배경색이 바뀌고, 하단에 선택한 좌석 수를 반영한 최종 가격이 표시된다.
- 선택된 좌석을 재선택하면 선택이 해제된다.
- 최종 예매를 확인하는 다이얼로그가 표시되고 배경을 터치해도 사라지지 않아야 한다.
- 주말에는 오전 9시부터 두 시간 간격으로 상영한다.
- 평일에는 오전 10시부터 두 시간 간격으로 상영한다.
- 날짜와 시간은 기본값으로 초기화되어있다.
- 영화 목록에 영화가 세 번 노출될 때마다 광고가 한 번 노출된다.
- 영화 목록의 요소는 10,000개까지 추가될 수 있다.
- UI Test
- Presenter Test

# 정리

## MVC vs MVP

MVC와 MVP 둘 다 역할과 책임을 분리한 소프트웨어 아키텍처 패턴이다.
이 두 패턴은 모델과 뷰의 의존성을 분리하여 애플리케이션의 코드를 구조화하고 유지보수 가능하도록 돕는다.

### MVC (Model-View-Controller)

- Model
    - 데이터와 비즈니스 로직을 담당
    - 애플리케이션의 상태를 유지 및 관리

- View
    - 사용자에게 데이터를 표시하고 사용자 입력을 받음
    - 모델의 상태를 기반으로 데이터를 표시

- Controller
    - 뷰와 모델 간의 중간자 역할
    - 사용자 입력을 처리하고 모델을 업데이트함
    - 모델의 상태 변화에 따라 뷰를 업데이트함

MVC에서는 컨트롤러가 모델과 뷰 사이의 중개자 역할을 담당한다. (N : N 관계)
모델과 뷰는 서로 직접적으로 의존하지 않으며, 이는 코드의 재사용성과 유지 보수성을 향상시킨다.
사용자로부터 입력을 받은 후 컨트롤러에게 메시지를 보내고,
컨트롤러는 뷰에게 받은 메시지를 통해 모델에게 특정 작업을 수행하도록 메시지를 보낸다.
다시 모델은 컨트롤러에게 데이터를 보내고 컨트롤러는 뷰에게 메시지를 보내어 사용자에게 표시한다.

### MVP (Model-View-Presenter)

- Model (모델)
    - 데이터와 비즈니스 로직을 담당
    - 애플리케이션의 상태를 유지하고 관리

- View (뷰)
    - 사용자에게 데이터를 표시하고 사용자 입력을 받음
    - 사용자의 액션을 처리할 수 있는 인터페이스를 제공

- Presenter (프레젠터)
    - 뷰와 모델 간의 중간자 역할
    - 사용자 입력을 처리하고 모델에 대한 작업을 수행
    - 모델의 상태 변화에 따라 뷰를 업데이트

MVP에서는 프레젠터가 뷰와 모델 간의 중개자 역할을 한다. (1 : 1 관계)
이 패턴은 뷰와 모델을 완전히 분리하여 테스트 용이성을 향상시킨다.
또한 뷰는 사용자 인터페이스만 담당하므로 더 깔끔하고 모듈화된 코드를 작성할 수 있다.
사용자의 인터렉션을 통해 뷰는 프레젠터에게 모델에 대한 작업을 수행하라고 메시지를 보내고
프레젠터는 모델의 상태 변화를 뷰에게 메시지를 보냄으로써 뷰가 업데이트하게 된다.
MVC와 다른 점은 추상화라고 할 수 있는데, MVP는 추상화를 통해 사용자의 동작을 캡슐화하며, 프레젠터는 인터페이스를 통해 뷰와 상호작용하고, 뷰는 이를 실행한다.

## UI Test와 Unit Test

(처음으로 UI Test를 진행한 경험을 토대로 작성한 것이다. 정말 정말 정말 개인적인 생각이다! 그냥 생각을 정리하기 위한 글이다!)

- UI Test는 화면에 표시되는 뷰들의 상태, 데이터 표시, 사용자의 상호 작용, 애니메이션 등을 테스트하는 데 사용된다.
- Unit Test는 어플리케이션에서 동작하는 작은 단위의 기능을 테스트하기 위해 사용된다. (클래스, 함수, Presenter, ViewModel 등..)

이번 미션에서 두 가지 테스트를 작성하면서 Unit Test를 통해 UI Test 영역을 일부 커버할 수 있다는 것을 알게 되었다.
결론부터 말하면, View에 데이터가 잘 표시되고 있는지를 테스트하는 것은 Unit Test로 충분히 할 수 있다는 것이다.
이는 UI 요구사항이 빈번하게 변경되는 상황에서도 유연하게 대응할 수 있는 방법이라고 생각한다.
또, 데이터가 View에 올바르게 표시되는지 확인하는 것은 Unit Test에서 충분히 가능하다고 생각한다.
(여기서 말하는 Unit Test는 데이터가 올바르게 표시될 것이라고 가정하고 해당 데이터로 인해 예상한 동작이 발생하는지 확인하는 것이다.)

따라서 UI Test는 사용자의 상호 작용을 통한 이벤트 결과를 테스트하는 데 적합하다고 생각한다. 예를 들어, 버튼 클릭에 따른 다이얼로그 표시, 토스트 메시지 표시, 다른
뷰의 나타남, 애니메이션 등이 있다.

반대로, Unit Test는 기능 및 비즈니스 로직을 담당하는 부분을 테스트하는 데 적합하다고 생각한다.

## ListView vs RecyclerView

ListView와 RecyclerView 모두 리스트뷰를 구현하기 위해 사용되는 라이브러리이며 무엇인가를 재활용하여 특정 아이템을 스크롤 한다는 공통점이 있다.
그러나 ListView는 View를 재활용하고 RecyclerView는 ViewHolder를 재활용한다.

### ListView

1. 단일 뷰로 이루어진 뷰를 표시하고 재활용한다.
2. getView()를 구현해야 한다.
    - convertView가 null일 경우에만 inflate 시킨 후 캐싱한다.
    - 재사용된 View가 넘어오면 새롭게 inflate하지 않고 캐싱된 View를 가져온다.
    - 그 후 View를 바인딩시켜 반환시킨다.
3. View를 계속 바인딩 시키는 것은 큰 비용이 발생한다.
4. 세로 방향 레이아웃 및 스크롤만 가능하다.
5. ViewHolder 패턴을 통해 RecyclerView와 유사하게 구현할 수 있다.(메모리 사용량 감소, 성능 향상) 그러나 ViewHolder 패턴이 강제되지 않아 개발자가
   실수할 수 있고, 애니메이션 및 다양한 레이아웃 관리 등의 RecyclerView의 기능을 구현하기 어렵다.

### RecyclerView

1. ViewHolder 패턴을 강제화하여 아이템을 재사용하므로 메모리 사용량이 줄어들고 스크롤 성능이 향상된다.
2. 다양한 레이아웃 매니저를 제공하여 수직, 수평, 그리드 형태 등 다양한 레이아웃을 구현할 수 있다.
3. ItemAnimator를 통해 아이템 추가, 삭제, 이동 등의 애니메이션을 쉽게 구현할 수 있다.

### ViewHolder 패턴이 뭔데???

ViewHolder 패턴은 각 View 객체를 ViewHolder라는 클래스에 보관함으로써
findViewById의 반복적 호출을 줄여 속도 개선을 할 수 있도록 하는 패턴이다.
즉, bind한 View를 재활용하는 것이다.

### 결론적으로..

RecyclerView는 ListView에 비해 성능이 우수하고 유연성이 높으며, 대부분의 경우에는 RecyclerView를 사용하는 것이 좋다.

## MockK 적용기

MockK를 도입하기 전에는 가짜 객체를 직접 구현하여 테스트를 진행했다.
새로운 기능을 추가할 때마다 가짜 객체에 해당 기능을 업데이트해야 했는데, 정말 번거로움이 많았다.

하지만 MockK를 도입한 후에는 직접 가짜 객체를 생성하지 않고 간단하게 mock 객체를 생성하여 테스트를 수행할 수 있어서 매우 편리했다.
아직 MockK에 익숙하지 않아 제대로 사용하고 있지는 않지만 충분히 학습할만한 라이브러리인 것 같다.
또, MockK의 장점을 전부 체감해보지는 못했기 때문에 여러 미션에서 활용해보고 싶다.

### 그런데 왜 Mockito가 아닌 MockK를 사용했나?!
Mockito는 자바를 기반으로 만들어진 라이브러리라서 자바, 코틀린이 혼용된 프로젝트에서 사용을 고려할 수 있고, 전부 코틀린으로 만들어진 프로젝트라면 MockK 사용을 고려할 수 있다
MockK가 Mockito에 비해 갖는 장점은 DSL을 통한 가독성 높은 코드 작성이 가능한 것, 코루틴 지원, 정적 함수(코틀린의 companion object function)의 mocking이다.

